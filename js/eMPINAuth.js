/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
 */

/**
 * @fileoverview New M-Pin Protocol functions
 */

/**
 * @namespace
 */
eMpinAuth = {};

// Debug output flag
eMpinAuth.DEBUG = true;

eMpinAuth.getPrng_ = function() {
	"use strict";

	var localEntropy = hexstr2bytes(MPINAuth.getLocalEntropy());

	var prng = new RAND();
	prng.clean();
	prng.seed(localEntropy.length, localEntropy);

	return prng;
};

/**
 * Get current time in milliseconds.
 * 
 * @return {integer} current time (msec)
 * 
 */
eMpinAuth.getTime = function() {
	"use strict";

	return Date.now();
};

/**
 * Client-side computation of the eM-Pin non-interactive protocol. This is the
 * deterministic function.
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            clientCurrentTime - current time at client's environment
 * @param {hex-string}
 *            token_hex - an encoded client secret
 * @param {hex-string}
 *            timePermit_hex - a time permit of an client generated by PKG
 *            server and SP
 * @param {string}
 *            pin - client knowledge
 * @param {hex-string}
 *            epochDays - the number of days since UNIX time
 * @param {BIG}
 *            x_bn - a random integer as temporary client secret
 * @param {BIG}
 *            nonce_bn - a random integer as nonce
 * @return {hash-array} consisting of the M-PIN ID, the points {U, V, W} in G1,
 *         the nonce and the client current time in hex-string
 * 
 */
eMpinAuth.authenticate_det = function(mpinId_hex, clientCurrentTime, token_hex,
		timePermit_hex, pin, epochDays, x_bn, nonce_bn) {
	"use strict";

	var bytes = [];

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var hashedMpinId_ba = hashIntoBytesFromBytes(mpinId_ba);
	var A = ECP.mapToPoint(hashedMpinId_ba);

	var nonce_hex = nonce_bn.toString();

	var pin_bn = BIG.fromBytes(hashIntoBytesFromString(pin));
	var aA = A.mul(pin_bn);

	var epochDays_ba = reverseBytes(uint2fixedLengthBytes(epochDays, 4));
	var TData = epochDays_ba.concat(hashedMpinId_ba);
	var T = ECP.mapToPoint(hashIntoBytesFromBytes(TData));

	var saA = ECP.fromBytes(hexstr2bytes(token_hex));
	var sT = ECP.fromBytes(hexstr2bytes(timePermit_hex));

	var D = new ECP();
	D.copy(A);
	D.add(T);
	var U = D.mul(x_bn);
	var W = A.mul(x_bn);

	U.toBytes(bytes);
	var U_hex = bytes2hexstr(bytes);

	W.toBytes(bytes);
	var W_hex = bytes2hexstr(bytes);

	var yData = mpinId_hex + U_hex + W_hex + nonce_hex + clientCurrentTime;
	var y_bn = BIG.fromBytes(hashIntoBytesFromString(yData));

	var xy_bn = new BIG(0);
	xy_bn.add(x_bn);
	xy_bn.add(y_bn);
	xy_bn.norm();

	var V = new ECP();
	V.copy(saA);
	V.add(aA);
	V.add(sT);
	V = V.mul(xy_bn);
	V.neg();

	V.toBytes(bytes);
	var V_hex = bytes2hexstr(bytes);

	if (eMpinAuth.DEBUG) {
		console.log("x : " + x_bn.toString());
		console.log("y : " + y_bn.toString());
		console.log("x+y : " + xy_bn.toString());
		console.log("U : " + U.toString());
		console.log("V : " + V.toString());
		console.log("W : " + W.toString());
		console.log("A : " + A.toString());
		console.log("T : " + T.toString());
		console.log("D : " + D.toString());
		console.log("U_hex : " + U_hex);
		console.log("W_hex : " + W_hex);
		console.log("V_hex : " + V_hex);
	}

	var eMpinRequest = {
		MpinId : mpinId_hex,
		U : U_hex,
		V : V_hex,
		W : W_hex,
		Nonce : nonce_hex,
		CCT : clientCurrentTime
	};

	return eMpinRequest;
};

/**
 * Server-side computation of the eM-Pin non-interactive protocol. This is the
 * deterministic function.
 * 
 * @param {hash-array}
 *            clientData - consisting of the MPIN ID, the points {U, V, W} in
 *            G1, the nonce, the client current time
 * @param {hex-string}
 *            serverSecret_hex - a point of a server secret in G2
 * @param {integer}
 *            epochDays - the number of days since UNIX time
 * @return {hash-array} consisting of the verification result
 * 
 */
eMpinAuth.verify_det = function(clientData, serverSecret_hex, epochDays) {
	"use strict";

	var eMpinResponse = {
		result : "ng"
	};

	var g2 = ECP2.getGenerator();

	var serverSecret_ba = hexstr2bytes(serverSecret_hex);
	var serverSecret = ECP2.fromBytes(serverSecret_ba);

	if (eMpinAuth.DEBUG) {
		console.log("mpk: " + serverSecret.toString());
	}

	var mpinId_hex = clientData.MpinId;
	var U_hex = clientData.U;
	var V_hex = clientData.V;
	var W_hex = clientData.W;
	var nonce_hex = clientData.Nonce;
	var clientCurrentTime = clientData.CCT;

	var U = ECP.fromBytes(hexstr2bytes(U_hex));
	var V = ECP.fromBytes(hexstr2bytes(V_hex));
	var W = ECP.fromBytes(hexstr2bytes(W_hex));

	if (eMpinAuth.DEBUG) {
		console.log("U: " + U.toString());
		console.log("V: " + V.toString());
		console.log("W: " + W.toString());
	}

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var hashedMpinId_ba = hashIntoBytesFromBytes(mpinId_ba);
	var A = ECP.mapToPoint(hashedMpinId_ba);

	var epochDays_ba = reverseBytes(uint2fixedLengthBytes(epochDays, 4));
	var TData = epochDays_ba.concat(hashedMpinId_ba);
	var T = ECP.mapToPoint(hashIntoBytesFromBytes(TData));

	var D = new ECP();
	D.copy(A);
	D.add(T);

	if (eMpinAuth.DEBUG) {
		console.log("A: " + A.toString());
		console.log("T: " + T.toString());
		console.log("D: " + D.toString());
	}

	var yData = mpinId_hex + U_hex + W_hex + nonce_hex + clientCurrentTime;
	var y_bn = BIG.fromBytes(hashIntoBytesFromString(yData));

	if (eMpinAuth.DEBUG) {
		console.log("y: " + y_bn.toString());
	}

	// verify
	var yD = D.mul(y_bn);
	var UyD = new ECP();
	UyD.copy(U);
	UyD.add(yD);

	var R_1 = PAIR.ate(serverSecret, UyD);
	var R_2 = PAIR.ate(g2, V);
	R_1.mul(R_2);
	var rst = PAIR.fexp(R_1);

	if (eMpinAuth.DEBUG) {
		console.log("e(SS, U+yD) e(g2, V): " + rst.toString());
	}

	if (rst.isunity()) {
		eMpinResponse.result = "ok";
	}
	return eMpinResponse;
};

/**
 * Client-side computation to check the activation code in the eM-Pin
 * non-interactive protocol. This is the deterministic function.
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            clientCurrentTime - current time of client's environment
 * @param {hex-string}
 *            x_bn - a random integer as temporary client secret
 * @return {hash-array} consisting of the M-PIN ID, the points {U, V} in G1
 * 
 */
eMpinAuth.activationCheck_det = function(mpinId_hex, clientSecret_hex, x_bn) {
	"use strict";

	var bytes = [];

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var A = ECP.mapToPoint(hashIntoBytesFromBytes(mpinId_ba));

	var sA = ECP.fromBytes(hexstr2bytes(clientSecret_hex));

	var U = A.mul(x_bn);

	U.toBytes(bytes);
	var U_hex = bytes2hexstr(bytes);

	var yData = mpinId_hex + U_hex;
	var y_bn = BIG.fromBytes(hashIntoBytesFromString(yData));

	var xy_bn = new BIG(0);
	xy_bn.add(x_bn);
	xy_bn.add(y_bn);
	xy_bn.norm();

	var V = new ECP();
	V.copy(sA);
	V = V.mul(xy_bn);
	V.neg();

	V.toBytes(bytes);
	var V_hex = bytes2hexstr(bytes);

	var eMpinActivationRequest = {
		MpinId : mpinId_hex,
		U : U_hex,
		V : V_hex
	};
	return eMpinActivationRequest;
};

/**
 * Server-side computation to check the activation code in the eM-Pin
 * non-interactive protocol. This is the deterministic function.
 * 
 * @param {hash-array}
 *            clientData - consisting of the M-PIN ID, the points {U, V} in G1
 * @param {hex-string}
 *            serverSecret_hex - a point of a server secret in G2
 * @return {hash-array} consisting of the verification result
 * 
 */
eMpinAuth.activationVerify_det = function(clientData, serverSecret_hex) {
	"use strict";

	var eMpinActivationResponse = {
		result : "ng"
	};

	var g2 = ECP2.getGenerator();

	var serverSecret_ba = hexstr2bytes(serverSecret_hex);
	var serverSecret = ECP2.fromBytes(serverSecret_ba);

	if (eMpinAuth.DEBUG) {
		console.log("mpk: " + serverSecret.toString());
	}

	var mpinId_hex = clientData.MpinId;
	var U_hex = clientData.U;
	var V_hex = clientData.V;

	var U = ECP.fromBytes(hexstr2bytes(U_hex));
	var V = ECP.fromBytes(hexstr2bytes(V_hex));

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var A = ECP.mapToPoint(hashIntoBytesFromBytes(mpinId_ba));

	var yData = mpinId_hex + U_hex;
	var y_bn = BIG.fromBytes(hashIntoBytesFromString(yData));

	// verify
	var yA = A.mul(y_bn);
	var UyA = new ECP();
	UyA.copy(U);
	UyA.add(yA);

	var R_1 = PAIR.ate(serverSecret, UyA);
	var R_2 = PAIR.ate(g2, V);
	R_1.mul(R_2);
	var rst = PAIR.fexp(R_1);

	if (eMpinAuth.DEBUG) {
		console.log("e(SS, U+yA) e(g2, V): " + rst.toString());
	}

	if (rst.isunity()) {
		eMpinActivationResponse.result = "ok";
	}

	return eMpinActivationResponse;
};

/**
 * Client-side computation of the eM-Pin non-interactive protocol. This is the
 * random function. It calls eMpinAuth.authenticate_det.
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            clientCurrentTime - current time of client's environment
 * @param {hex-string}
 *            token_hex - an encoded client secret
 * @param {hex-string}
 *            timePermit_hex - a time permit of a client generated by PKG and SP
 *            servers
 * @param {string}
 *            pin - client knowledge
 * @return {hash-array} consisting of the M-PIN ID, the points {U, V, W} in G1,
 *         the nonce and the client current time in hex-string
 * 
 */
eMpinAuth.authenticate = function(mpinId_hex, clientCurrentTime, token_hex,
		timePermit_hex, pin) {
	"use strict";

	var prng = eMpinAuth.getPrng_();

	var epochDays = Math.floor(parseInt(clientCurrentTime, 16)
			/ (3600 * 24 * 1000));

	var x_ba = [], n_ba = [];
	for (var i = 0; i < ROM.MODBYTES; i++) {
		x_ba.push(prng.getByte());
		n_ba.push(prng.getByte());
	}
	var x_bn = BIG.fromBytes(x_ba);
	var nonce_bn = BIG.fromBytes(n_ba);

	if (eMpinAuth.DEBUG) {
		console.log("CCT(hex) :" + clientCurrentTime);
		console.log("epochDays: " + epochDays);

		console.log("x_bn" + x_bn.toString());
		console.log("nonce_bn" + nonce_bn.toString());
	}

	return eMpinAuth.authenticate_det(mpinId_hex, clientCurrentTime, token_hex,
			timePermit_hex, pin, epochDays, x_bn, nonce_bn);
};

/**
 * Server-side computation of the eM-Pin non-interactive protocol. It calls
 * eMpinAuth.verify_det.
 * 
 * @param {hash-array}
 *            clientData - consisting of M-PIN ID, the points {U, V, W} in G1,
 *            the nonce, the client current time
 * @param {hex-string}
 *            serverSecret_hex - a point of a server secret in G2
 * @return {hash-array} consisting of the verification result
 * 
 */
eMpinAuth.verify = function(clientData, serverSecret_hex) {
	"use strict";

	var serverCurrentTime = eMpinAuth.getTime().toString(16);
	var epochDays = Math.floor(parseInt(serverCurrentTime, 16)
			/ (3600 * 24 * 1000));

	if (eMpinAuth.DEBUG) {
		console.log("SCT(hex): " + serverCurrentTime);
		console.log("epochDays: " + epochDays);
	}

	return eMpinAuth.verify_det(clientData, serverSecret_hex, epochDays);
};

/**
 * Client-side computation to check the activation code in the eM-Pin
 * non-interactive protocol. This is the random function. It calls
 * eMpinAuth.activationCheck_det.
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            clientSecret_hex - a point of a current secret in G1
 * @return {hash-array} consisting of the M-PIN ID, the points {U, V} in G1
 * 
 */
eMpinAuth.activationCheck = function(mpinId_hex, clientSecret_hex) {
	"use strict";

	var prng = eMpinAuth.getPrng_();

	var x_ba = [];
	for (var i = 0; i < ROM.MODBYTES; i++) {
		x_ba.push(prng.getByte());
	}
	var x_bn = BIG.fromBytes(x_ba);

	return eMpinAuth.activationCheck_det(mpinId_hex, clientSecret_hex, x_bn);
};

/**
 * Server-side computation to check the activation code in the eM-Pin
 * non-interactive protocol. It calls eMpinAuth.ctivationVerify_det.
 * 
 * @param {hash-array}
 *            clientData - consisting of M-PIN ID, the points {U, V} in G1
 * @param {hex-string}
 *            serverSecret_hex - a point of a server secret in G2
 * @return {hash-array} consisting of the verification result
 * 
 */
eMpinAuth.activationVerify = function(clientData, serverSecret_hex) {
	"use strict";

	return eMpinAuth.activationVerify_det(clientData, serverSecret_hex);
};

/**
 * Encode/decode a (parted) client secret with the Activation Code in Integer.
 * It uses at a activation phase.
 * 
 * For H(ID) = A in G1, an activation code x = scalarVal in N,
 * <li> if isEncode is true, then compute sA - xA s.t. the client secret sA in
 * G1,</li>
 * <li> if isEncode is false, then compute (s-x)A + xA s.t. the encoded client
 * secret (s-x)A in G1.</li>
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            point_hex - an original/encoded client secret
 * @param {integer}
 *            scalarVal - an n-digit activation code generated by SP server
 * @param {boolean}
 *            isEncode - an encode/decode flag
 * @return {hex-string} the encoded/original client secret computed by the
 *         activation code
 */
eMpinAuth.calcClientSecretWithActivationCode = function(mpinId_hex, point_hex,
		scalarVal, isEncode) {
	"use strict";

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var A = ECP.mapToPoint(hashIntoBytesFromBytes(mpinId_ba));

	var scalarVal_ba = uint2bytes(scalarVal);
	var hashedScalarVal_bn = BIG
			.fromBytes(hashIntoBytesFromBytes(scalarVal_ba));
	var xA = A.mul(hashedScalarVal_bn);

	var tA = ECP.fromBytes(hexstr2bytes(point_hex));

	if (isEncode) {
		tA.sub(xA);
	} else {
		tA.add(xA);
	}

	var bytes = [];
	tA.toBytes(bytes);
	return bytes2hexstr(bytes);
};

/**
 * Encode/decode a (parted) client secret with the PIN presented by ACSII
 * string. It uses at a registration phase for computing the client token.
 * 
 * For H(ID) = A in G1, a hashed PIN x = H_N(scalarVal) in N,
 * <li> if isEncode is true, then compute sA - xA s.t. the client secret sA in
 * G1,</li>
 * <li> if isEncode is false, then compute (s-x)A + xA s.t. the encoded client
 * secret (s-x)A in G1.</li>
 * 
 * @param {hex-string}
 *            mpinId_hex - a client M-PIN ID
 * @param {hex-string}
 *            point_hex - an original/encoded client secret
 * @param {string}
 *            scalarVal - client knowledge
 * @param {boolean}
 *            isEncode - an encode/decode flag
 * @return {hex-string} the encoded/original client secret computed by the PIN
 * 
 */
eMpinAuth.calcClientSecretWithStringPin = function(mpinId_hex, point_hex,
		scalarVal, isEncode) {
	"use strict";

	var mpinId_ba = hexstr2bytes(mpinId_hex);
	var A = ECP.mapToPoint(hashIntoBytesFromBytes(mpinId_ba));

	var hashedScalarVal_bn = BIG.fromBytes(hashIntoBytesFromString(scalarVal));
	var xA = A.mul(hashedScalarVal_bn);

	var tA = ECP.fromBytes(hexstr2bytes(point_hex));

	if (isEncode) {
		tA.sub(xA);
	} else {
		tA.add(xA);
	}

	var bytes = [];
	tA.toBytes(bytes);
	return bytes2hexstr(bytes);
};
