/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/

package mpin

/*
#cgo CFLAGS:  -std=c99 -O3 -I. -I@CMAKE_INSTALL_PREFIX@/include
#cgo LDFLAGS: -L. -L@CMAKE_INSTALL_PREFIX@/lib -lmpin  -lamcl -lm
#include <stdio.h>
#include <stdlib.h>
#include "amcl.h"
#include "mpin.h"
#include "utils.h"
*/
import "C"
import (
	"encoding/hex"
	"fmt"
	"unsafe"
)

const EAS int = int(C.PAS)
const EGS int = int(C.PGS)
const EFS int = int(C.PFS)
const HASH_BYTES int = int(C.PFS)
const IVS int = 12
const G1S = 2 * EFS + 1
const G2S = 4 * EFS
const GTS = 12 * EFS

//  Hash function choice
const SHA256 int = 32
const SHA384 int = 48
const SHA512 int = 64

func OctetFree(valOctet *C.octet) {
	C.free(unsafe.Pointer(valOctet.val))
}

func GetOctetZero(lenStr int) C.octet {
	valBytes := make([]byte, lenStr)
	val := string(valBytes)
	valCS := C.CString(val)
	lenCS := C.int(lenStr)
	octetVal := C.octet{lenCS, lenCS, valCS}
	return octetVal
}

func GetOctet(valStr string) C.octet {
	valCS := C.CString(valStr)
	lenCS := C.int(len(valStr))
	octetVal := C.octet{lenCS, lenCS, valCS}
	return octetVal
}

func GetOctetHex(valHex string) C.octet {
	valBytes, err := hex.DecodeString(valHex)
	if err != nil {
		octetVal := GetOctetZero(0)
		return octetVal
	}
	valStr := string(valBytes)
	octetVal := GetOctet(valStr)
	return octetVal
}

func OctetLen(valOctet *C.octet) int {
	return int(valOctet.len)
}

// Convert an octet to a string
func OctetToString(valOct *C.octet) string {
	dstLen := OctetLen(valOct)
	dstBytes := make([]byte, dstLen)
	dstStr := string(dstBytes)
	dst := C.CString(dstStr)
	C.OCT_toStr(valOct, dst)
	dstStr = C.GoStringN(dst, valOct.len)
	C.free(unsafe.Pointer(dst))
	return dstStr
}

// Convert an octet to bytes
func OctetToBytes(valOct *C.octet) []byte {
	dstLen := OctetLen(valOct)
	dstBytes := make([]byte, dstLen)
	dstStr := string(dstBytes)
	dst := C.CString(dstStr)
	C.OCT_toStr(valOct, dst)
	dstStr = C.GoStringN(dst, valOct.len)
	C.free(unsafe.Pointer(dst))
	dstBytes = []byte(dstStr)
	return dstBytes
}

// Convert an octet to a hex string
func OctetToHex(valOctet *C.octet) string {
	dstLen := OctetLen(valOctet)
	dstBytes := make([]byte, hex.EncodedLen(dstLen))
	dstStr := string(dstBytes)
	dst := C.CString(dstStr)
	C.OCT_toHex(valOctet, dst)
	dstStr = C.GoString(dst)
	C.free(unsafe.Pointer(dst))
	return dstStr
}

/* return time in slots since epoch */
func Today() int {
	date := C.MPIN_today()
	return int(date)
}

/* return time since epoch */
func GetTime() int {
	timeValue := C.MPIN_GET_TIME()
	return int(timeValue)
}

func CreateCSPRNG(SEED []byte) C.csprng {
	// Form Octet
	SEEDStr := string(SEED)
	SEEDOct := GetOctet(SEEDStr)
	defer OctetFree(&SEEDOct)
	var RNG C.csprng
	C.MPIN_CREATE_CSPRNG(&RNG, &SEEDOct)
	return RNG
}

func HashId(hashType int, ID []byte) (HashId []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	HashIdOct := GetOctetZero(HASH_BYTES)
	defer OctetFree(&HashIdOct)

	// Hash MPIN_ID
	C.MPIN_HASH_ID(C.int(hashType), &IDOct, &HashIdOct)

	// Convert octet to bytes
	HashId = OctetToBytes(&HashIdOct)

	return HashId
}

/* create random secret S. Uses C RNG */
func RandomGenerate(RNG *C.csprng) (errorCode int, S []byte) {
	// Form Octet
	SOct := GetOctetZero(EGS)
	defer OctetFree(&SOct)

	rtn := C.MPIN_RANDOM_GENERATE(RNG, &SOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	S = OctetToBytes(&SOct)

	return errorCode, S[:]
}

/* Extract Server Secret SS=S*Q where Q is fixed generator in G2 and S is master secret */
func GetServerSecret(S []byte) (errorCode int, SS []byte) {
	// Form Octets
	SStr := string(S)
	SOct := GetOctet(SStr)
	defer OctetFree(&SOct)
	SSOct := GetOctetZero(G2S)
	defer OctetFree(&SSOct)

	rtn := C.MPIN_GET_SERVER_SECRET(&SOct, &SSOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	SS = OctetToBytes(&SSOct)

	return errorCode, SS[:]
}

/* R=R1+R2 in group G1 */
func RecombineG1(R1 []byte, R2 []byte) (errorCode int, R []byte) {
	// Form Octets
	R1Str := string(R1)
	R1Oct := GetOctet(R1Str)
	defer OctetFree(&R1Oct)
	R2Str := string(R2)
	R2Oct := GetOctet(R2Str)
	defer OctetFree(&R2Oct)
	ROct := GetOctetZero(G1S)
	defer OctetFree(&ROct)

	rtn := C.MPIN_RECOMBINE_G1(&R1Oct, &R2Oct, &ROct)
	errorCode = int(rtn)

	// Convert octet to bytes
	R = OctetToBytes(&ROct)

	return errorCode, R[:]
}

/* W=W1+W2 in group G2 */
func RecombineG2(W1 []byte, W2 []byte) (errorCode int, W []byte) {
	// Form Octets
	W1Str := string(W1)
	W1Oct := GetOctet(W1Str)
	defer OctetFree(&W1Oct)
	W2Str := string(W2)
	W2Oct := GetOctet(W2Str)
	defer OctetFree(&W2Oct)
	WOct := GetOctetZero(G2S)
	defer OctetFree(&WOct)

	rtn := C.MPIN_RECOMBINE_G2(&W1Oct, &W2Oct, &WOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	W = OctetToBytes(&WOct)

	return errorCode, W[:]
}

/* Client secret CS=S*H(ID) where ID is client ID and S is master secret */
/* CID is hashed externally */
func GetClientSecret(S []byte, ID []byte) (errorCode int, CS []byte) {
	// Form Octets
	SStr := string(S)
	SOct := GetOctet(SStr)
	defer OctetFree(&SOct)
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	CSOct := GetOctetZero(G1S)
	defer OctetFree(&CSOct)

	rtn := C.MPIN_GET_CLIENT_SECRET(&SOct, &IDOct, &CSOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	CS = OctetToBytes(&CSOct)

	return errorCode, CS[:]
}

/* Time Permit TP=S*(date|H(ID)) where S is master secret */
func GetClientPermit(hashType, date int, S, ID []byte) (errorCode int, TP []byte) {
	// Form Octets
	SStr := string(S)
	SOct := GetOctet(SStr)
	defer OctetFree(&SOct)
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	TPOct := GetOctetZero(G1S)
	defer OctetFree(&TPOct)

	rtn := C.MPIN_GET_CLIENT_PERMIT(C.int(hashType), C.int(date), &SOct, &IDOct, &TPOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	TP = OctetToBytes(&TPOct)

	return errorCode, TP[:]
}

/* Extract PIN from CS for identity CID to form TOKEN */
func ExtractPIN(hashType int, ID []byte, PIN int, CS []byte) (errorCode int, TOKEN []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	CSStr := string(CS)
	CSOct := GetOctet(CSStr)
	defer OctetFree(&CSOct)

	rtn := C.MPIN_EXTRACT_PIN(C.int(hashType), &IDOct, C.int(PIN), &CSOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	TOKEN = OctetToBytes(&CSOct)

	return errorCode, TOKEN[:]
}

/* One pass MPIN Client. Using C RNG */
func Client(hashType, date int, ID []byte, RNG *C.csprng, X []byte, PIN int, TOKEN []byte, TP []byte, MESSAGE []byte, TimeValue int) (errorCode int, XOut, Y, SEC, U, UT []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	XStr := string(X)
	XOct := GetOctet(XStr)
	defer OctetFree(&XOct)
	TOKENStr := string(TOKEN)
	TOKENOct := GetOctet(TOKENStr)
	defer OctetFree(&TOKENOct)
	TPStr := string(TP)
	TPOct := GetOctet(TPStr)
	defer OctetFree(&TPOct)
	MESSAGEStr := string(MESSAGE)
	MESSAGEOct := GetOctet(MESSAGEStr)
	defer OctetFree(&MESSAGEOct)

	SECOct := GetOctetZero(G1S)
	defer OctetFree(&SECOct)
	UOct := GetOctetZero(G1S)
	defer OctetFree(&UOct)
	UTOct := GetOctetZero(G1S)
	defer OctetFree(&UTOct)
	YOct := GetOctetZero(EGS)
	defer OctetFree(&YOct)

	rtn := C.MPIN_CLIENT(C.int(hashType), C.int(date), &IDOct, RNG, &XOct, C.int(PIN), &TOKENOct, &SECOct, &UOct, &UTOct, &TPOct, &MESSAGEOct, C.int(TimeValue), &YOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	XOut = OctetToBytes(&XOct)
	SEC = OctetToBytes(&SECOct)
	U = OctetToBytes(&UOct)
	UT = OctetToBytes(&UTOct)
	Y = OctetToBytes(&YOct)

	return errorCode, XOut[:], Y[:], SEC[:], U[:], UT[:]
}

// Precompute values for use by the client side of M-Pin Full
func Precompute(TOKEN []byte, ID []byte) (errorCode int, GT1 []byte, GT2 []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	TOKENStr := string(TOKEN)
	TOKENOct := GetOctet(TOKENStr)
	defer OctetFree(&TOKENOct)

	GT1Oct := GetOctetZero(GTS)
	defer OctetFree(&GT1Oct)
	GT2Oct := GetOctetZero(GTS)
	defer OctetFree(&GT2Oct)

	rtn := C.MPIN_PRECOMPUTE(&TOKENOct, &IDOct, nil, &GT1Oct, &GT2Oct)
	errorCode = int(rtn)

	// Convert octet to bytes
	GT1 = OctetToBytes(&GT1Oct)
	GT2 = OctetToBytes(&GT2Oct)

	return errorCode, GT1[:], GT2[:]
}

/*
 W=x*H(G);
 if RNG == NULL then X is passed in
 if RNG != NULL the X is passed out
 if typ=0 W=x*G where G is point on the curve, else W=x*M(G), where M(G) is mapping of octet G to point on the curve
 Use C RNG
*/
func GetG1Multiple(RNG *C.csprng, typ int, X []byte, G []byte) (errorCode int, XOut, W []byte) {
	XStr := string(X)
	XOct := GetOctet(XStr)
	defer OctetFree(&XOct)
	GStr := string(G)
	GOct := GetOctet(GStr)
	defer OctetFree(&GOct)

	WOct := GetOctetZero(G1S)
	defer OctetFree(&WOct)

	rtn := C.MPIN_GET_G1_MULTIPLE(RNG, C.int(typ), &XOct, &GOct, &WOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	XOut = OctetToBytes(&XOct)
	W = OctetToBytes(&WOct)

	return errorCode, XOut[:], W[:]
}

/* One pass MPIN Server */
func Server(hashType, date, TimeValue int, SS, U, UT, V, ID, MESSAGE []byte) (errorCode int, HID, HTID, Y, E, F []byte) {
	SSStr := string(SS)
	SSOct := GetOctet(SSStr)
	defer OctetFree(&SSOct)
	UStr := string(U)
	UOct := GetOctet(UStr)
	defer OctetFree(&UOct)
	UTStr := string(UT)
	UTOct := GetOctet(UTStr)
	defer OctetFree(&UTOct)
	VStr := string(V)
	VOct := GetOctet(VStr)
	defer OctetFree(&VOct)
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)
	MESSAGEStr := string(MESSAGE)
	MESSAGEOct := GetOctet(MESSAGEStr)
	defer OctetFree(&MESSAGEOct)

	HIDOct := GetOctetZero(G1S)
	defer OctetFree(&HIDOct)
	HTIDOct := GetOctetZero(G1S)
	defer OctetFree(&HTIDOct)
	YOct := GetOctetZero(EGS)
	defer OctetFree(&YOct)
	EOct := GetOctetZero(GTS)
	defer OctetFree(&EOct)
	FOct := GetOctetZero(GTS)
	defer OctetFree(&FOct)

	rtn := C.MPIN_SERVER(C.int(hashType), C.int(date), &HIDOct, &HTIDOct, &YOct, &SSOct, &UOct, &UTOct, &VOct, &EOct, &FOct, &IDOct, &MESSAGEOct, C.int(TimeValue))
	errorCode = int(rtn)

	// Convert octet to bytes
	HID = OctetToBytes(&HIDOct)
	HTID = OctetToBytes(&HTIDOct)
	Y = OctetToBytes(&YOct)
	E = OctetToBytes(&EOct)
	F = OctetToBytes(&FOct)

	return errorCode, HID[:], HTID[:], Y[:], E[:], F[:]
}

/* Pollards kangaroos used to return PIN error */
func Kangaroo(E []byte, F []byte) (PINError int) {
	EStr := string(E)
	EOct := GetOctet(EStr)
	defer OctetFree(&EOct)
	FStr := string(F)
	FOct := GetOctet(FStr)
	defer OctetFree(&FOct)

	rtn := C.MPIN_KANGAROO(&EOct, &FOct)
	PINError = int(rtn)

	return PINError
}

/* calculate common key on server side */
/* Z=r.A - no time permits involved */
func ServerKey(hashType int, Z, SS, W, P, I, U, UT []byte) (errorCode int, SK []byte) {
	ZStr := string(Z)
	ZOct := GetOctet(ZStr)
	defer OctetFree(&ZOct)
	SSStr := string(SS)
	SSOct := GetOctet(SSStr)
	defer OctetFree(&SSOct)
	WStr := string(W)
	WOct := GetOctet(WStr)
	defer OctetFree(&WOct)
	PStr := string(P)
	POct := GetOctet(PStr)
	defer OctetFree(&POct)
	IStr := string(I)
	IOct := GetOctet(IStr)
	defer OctetFree(&IOct)
	UStr := string(U)
	UOct := GetOctet(UStr)
	defer OctetFree(&UOct)
	UTStr := string(UT)
	UTOct := GetOctet(UTStr)
	defer OctetFree(&UTOct)

	SKOct := GetOctetZero(EAS)
	defer OctetFree(&SKOct)

	rtn := C.MPIN_SERVER_KEY(C.int(hashType), &ZOct, &SSOct, &WOct, &POct, &IOct, &UOct, &UTOct, &SKOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	SK = OctetToBytes(&SKOct)

	return errorCode, SK[:]
}

/* calculate common key on client side */
/* wCID = w.(A+AT) */
func ClientKey(hashType, PIN int, GT1, GT2, R, X, P, T []byte) (errorCode int, CK []byte) {
	GT1Str := string(GT1)
	GT1Oct := GetOctet(GT1Str)
	defer OctetFree(&GT1Oct)
	GT2Str := string(GT2)
	GT2Oct := GetOctet(GT2Str)
	defer OctetFree(&GT2Oct)
	RStr := string(R)
	ROct := GetOctet(RStr)
	defer OctetFree(&ROct)
	XStr := string(X)
	XOct := GetOctet(XStr)
	defer OctetFree(&XOct)
	PStr := string(P)
	POct := GetOctet(PStr)
	defer OctetFree(&POct)
	TStr := string(T)
	TOct := GetOctet(TStr)
	defer OctetFree(&TOct)

	CKOct := GetOctetZero(EAS)
	defer OctetFree(&CKOct)

	rtn := C.MPIN_CLIENT_KEY(C.int(hashType), &GT1Oct, &GT2Oct, C.int(PIN), &ROct, &XOct, &POct, &TOct, &CKOct)
	errorCode = int(rtn)

	// Convert octet to bytes
	CK = OctetToBytes(&CKOct)

	return errorCode, CK[:]
}

// Generate a random byte array
func GenerateRandomByte(RNG *C.csprng, randomLen int) (random []byte) {
	randomOct := GetOctetZero(randomLen)
	defer OctetFree(&randomOct)

	C.generateRandom(RNG, &randomOct)

	// Convert octet to bytes
	random = OctetToBytes(&randomOct)

	return
}

// Generate random six digit value
func GenerateOTP(RNG *C.csprng) int {
	rtn := C.generateOTP(RNG)
	return int(rtn)
}

/* AES-GCM Encryption:
   K is key, H is header, IV is initialization vector and P is plaintext.
   Returns cipthertext and tag (MAC) */
func AesGcmEncrypt(K, IV, H, P []byte) ([]byte, []byte) {
	KStr := string(K)
	KOct := GetOctet(KStr)
	defer OctetFree(&KOct)
	IVStr := string(IV)
	IVOct := GetOctet(IVStr)
	defer OctetFree(&IVOct)
	HStr := string(H)
	HOct := GetOctet(HStr)
	defer OctetFree(&HOct)
	PStr := string(P)
	POct := GetOctet(PStr)
	defer OctetFree(&POct)

	TOct := GetOctetZero(16)
	defer OctetFree(&TOct)
	lenC := len(PStr)
	COct := GetOctetZero(lenC)
	defer OctetFree(&COct)

	C.MPIN_AES_GCM_ENCRYPT(&KOct, &IVOct, &HOct, &POct, &COct, &TOct)

	// Convert octet to bytes
	C := OctetToBytes(&COct)
	T := OctetToBytes(&TOct)

	return C, T[:]
}

/* AES-GCM Decryption:
   K is key, H is header, IV is initialization vector and P is plaintext.
   Returns cipthertext and tag (MAC) */
func AesGcmDecrypt(K, IV, H, C []byte) ([]byte, []byte) {
	KStr := string(K)
	KOct := GetOctet(KStr)
	defer OctetFree(&KOct)
	IVStr := string(IV)
	IVOct := GetOctet(IVStr)
	defer OctetFree(&IVOct)
	HStr := string(H)
	HOct := GetOctet(HStr)
	defer OctetFree(&HOct)
	CStr := string(C)
	COct := GetOctet(CStr)
	defer OctetFree(&COct)

	TOct := GetOctetZero(16)
	defer OctetFree(&TOct)
	lenP := len(CStr)
	POct := GetOctetZero(lenP)
	defer OctetFree(&POct)

	C.MPIN_AES_GCM_DECRYPT(&KOct, &IVOct, &HOct, &COct, &POct, &TOct)

	// Convert octet to bytes
	P := OctetToBytes(&POct)
	T := OctetToBytes(&TOct)

	return P, T[:]
}

func PrintBinary(array []byte) {
	for i := 0; i < len(array); i++ {
		fmt.Printf("%02x", array[i])
	}
	fmt.Printf("\n")
}

/* Outputs H(CID) and H(T|H(CID)) for time permits. If no time permits set HID=HTID */
func Server1(hashType, date int, ID []byte) (HID, HTID []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)

	HIDOct := GetOctetZero(G1S)
	defer OctetFree(&HIDOct)
	HTIDOct := GetOctetZero(G1S)
	defer OctetFree(&HTIDOct)

	C.MPIN_SERVER_1(C.int(hashType), C.int(date), &IDOct, &HIDOct, &HTIDOct)

	// Convert octet to bytes
	HID = OctetToBytes(&HIDOct)
	HTID = OctetToBytes(&HTIDOct)

	return HID[:], HTID[:]
}

/* Implement step 2 of MPin protocol on server side */
func Server2(date int, HID []byte, HTID []byte, Y []byte, SS []byte, U []byte, UT []byte, V []byte) (errorCode int, E, F []byte) {
	// Form Octets
	HIDStr := string(HID)
	HIDOct := GetOctet(HIDStr)
	defer OctetFree(&HIDOct)
	HTIDStr := string(HTID)
	HTIDOct := GetOctet(HTIDStr)
	defer OctetFree(&HTIDOct)
	YStr := string(Y)
	YOct := GetOctet(YStr)
	defer OctetFree(&YOct)
	SSStr := string(SS)
	SSOct := GetOctet(SSStr)
	defer OctetFree(&SSOct)
	UStr := string(U)
	UOct := GetOctet(UStr)
	defer OctetFree(&UOct)
	UTStr := string(UT)
	UTOct := GetOctet(UTStr)
	defer OctetFree(&UTOct)
	VStr := string(V)
	VOct := GetOctet(VStr)
	defer OctetFree(&VOct)

	EOct := GetOctetZero(GTS)
	defer OctetFree(&EOct)
	FOct := GetOctetZero(GTS)
	defer OctetFree(&FOct)
	rtn := C.MPIN_SERVER_2(C.int(date), &HIDOct, &HTIDOct, &YOct, &SSOct, &UOct, &UTOct, &VOct, &EOct, &FOct)

	errorCode = int(rtn)
	E = OctetToBytes(&EOct)
	F = OctetToBytes(&FOct)

	return errorCode, E[:], F[:]
}

/* Implement step 1 on client side of MPin protocol
   When rng=nil the X value is externally generated
*/
func Client1(hashType, date int, ID []byte, rng *C.csprng, X []byte, PIN int, TOKEN []byte, TP []byte) (errorCode int, XOut, SEC, U, UT []byte) {
	// Form Octets
	IDStr := string(ID)
	IDOct := GetOctet(IDStr)
	defer OctetFree(&IDOct)

	XStr := string(X)
	XOct := GetOctet(XStr)
	defer OctetFree(&XOct)

	TOKENStr := string(TOKEN)
	TOKENOct := GetOctet(TOKENStr)
	defer OctetFree(&TOKENOct)

	TPStr := string(TP)
	TPOct := GetOctet(TPStr)
	defer OctetFree(&TPOct)

	SECOct := GetOctetZero(G1S)
	defer OctetFree(&SECOct)
	UOct := GetOctetZero(G1S)
	defer OctetFree(&UOct)
	UTOct := GetOctetZero(G1S)
	defer OctetFree(&UTOct)

	rtn := C.MPIN_CLIENT_1(C.int(hashType), C.int(date), &IDOct, rng, &XOct, C.int(PIN), &TOKENOct, &SECOct, &UOct, &UTOct, &TPOct)

	errorCode = int(rtn)
	// Convert octet to bytes
	XOut = OctetToBytes(&XOct)
	SEC = OctetToBytes(&SECOct)
	U = OctetToBytes(&UOct)
	UT = OctetToBytes(&UTOct)

	return errorCode, XOut[:], SEC[:], U[:], UT[:]
}

/* Implement step 2 on client side of MPin protocol */
func Client2(X []byte, Y []byte, SEC []byte) (errorCode int, V []byte) {
	// Form Octets
	XStr := string(X)
	XOct := GetOctet(XStr)
	defer OctetFree(&XOct)
	YStr := string(Y)
	YOct := GetOctet(YStr)
	defer OctetFree(&YOct)
	SECStr := string(SEC)
	SECOct := GetOctet(SECStr)
	defer OctetFree(&SECOct)

	rtn := C.MPIN_CLIENT_2(&XOct, &YOct, &SECOct)

	errorCode = int(rtn)
	// Convert octet to bytes
	V = OctetToBytes(&SECOct)

	return errorCode, V[:]
}

func HashAll(hashType int, I, U, UT, V, Y, R, W []byte) (HM []byte) {
	// Form Octets
	IStr := string(I)
	IOct := GetOctet(IStr)
	defer OctetFree(&IOct)

	UStr := string(U)
	UOct := GetOctet(UStr)
	defer OctetFree(&UOct)

	UTStr := string(UT)
	UTOct := GetOctet(UTStr)
	defer OctetFree(&UTOct)

	YStr := string(Y)
	YOct := GetOctet(YStr)
	defer OctetFree(&YOct)

	VStr := string(V)
	VOct := GetOctet(VStr)
	defer OctetFree(&VOct)

	RStr := string(R)
	ROct := GetOctet(RStr)
	defer OctetFree(&ROct)

	WStr := string(W)
	WOct := GetOctet(WStr)
	defer OctetFree(&WOct)

	HMOct := GetOctetZero(HASH_BYTES)
	defer OctetFree(&HMOct)

	// Hash values
	C.MPIN_HASH_ALL(C.int(hashType), &IOct, &UOct, &UTOct, &VOct, &YOct, &ROct, &WOct, &HMOct)

	// Convert octet to bytes
	HM = OctetToBytes(&HMOct)

	return HM[:]
}
